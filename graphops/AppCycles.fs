module AppCycles

open System
open System.IO
open System.Reflection

open Newtonsoft.Json

open TteLcl.Graphs
open TteLcl.Graphs.Analysis

open ColorPrint
open CommonTools

type private OperatingMode =
  | Tag
  | Split of string

type private Options = {
  InputFile: string
  OutputFile: string
  Mode: OperatingMode
}

let private runCycles o =
  cp "\frNot Yet Implemented\f0."
  1

let run args =
  let rec parseMore o args =
    match args with
    | "-v" :: rest ->
      verbose <- true
      rest |> parseMore o
    | "--help" :: _
    | "-h" :: _ ->
      None
    | "-i" :: file :: rest ->
      rest |> parseMore {o with InputFile = file}
    | "-o" :: file :: rest ->
      rest |> parseMore {o with OutputFile = file}
    | "-tag" :: rest ->
      rest |> parseMore {o with Mode = OperatingMode.Tag}
    | "-split" :: splitFile :: rest ->
      rest |> parseMore {o with Mode = OperatingMode.Split splitFile}
    | [] ->
      if o.InputFile |> String.IsNullOrEmpty then
        cp "\foNo input file (\fg-i\fo) given\f0."
        None
      else
        let missingOutputName = o.OutputFile |> String.IsNullOrEmpty
        let o = {o with OutputFile = Graph.DeriveMissingName(o.InputFile, ".pure.graph.json", o.OutputFile)}
        if o.OutputFile |> String.IsNullOrEmpty then
          let shortInput = Path.GetFileName(o.InputFile)
          cp $"\foNo output file (\fg-o\f0) given, and cannot derive the output name from \f0'{shortInput}\f0'"
          None
        else
          if missingOutputName then
            cp $"Using output name \fc{o.OutputFile}\f0."
          o |> Some
    | x :: _ ->
      cp $"\frUnrecognized argument \f0'\fy{x}\f0'"
      None
  let oo = args |> parseMore {
    InputFile = null
    OutputFile = null
    Mode = OperatingMode.Tag
  }
  match oo with
  | Some(o) ->
    o |> runCycles
  | None ->
    cp ""
    Usage.usage "cycles"
    1

